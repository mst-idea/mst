# 模型规划树(MST)之灵感

**模型规划树** (MST, Model Specification Tree) 的灵感源于大语言**模型** (Model) + **规划树** (Specification Tree)，即：利用大语言模型理解描述并输出各类产物的功能，实现规划树这种系统工程管理方法中尽可能多的中间步骤，以尽可能减少大模型工作过程中不必要的重复人工操作，并实现更高质量的输出。

## 0. 前言

在本文写成的时代，大语言模型(LLM)技术已经发展到新的历史阶段。在过去的百余年里，尤其是设计研发方面的系统工程管理方法，即便在仅能依靠人类手动执行的阶段受到技术和人力资源限制，但也有了充分的积累。在这样的时代背景下，过去由于人力资源成本限制导致难以实施的很多更细节的管理方法便有望在大模型的辅助下实现，也有望驱动各类大模型实现更复杂的任务需求，实现更有效的反馈和更稳定的输出，让人类能专注于灵感和创意，仅介入尽可能少的必要研发生产过程。

本文并非阐述某种具体的标准规范或应用实现，本文仅是对大模型应用与系统工程结合的想法和观点。尽管本文作者也在尝试开发软件通过实践验证，但本文仅阐述作为纯粹灵感的“模型规划树(MST)”的概念。本文作者并不希望此概念被任何(包括作者本人开发的)软件或产品所裹挟，因此在产生此灵感后立即将其整理成这篇文章，并开源分享给所有人。

关于其名称，为何要称为“模型规划树”而非“模型规范树”：这里的“规”就已经有“规范(Specification)”的含义，而“规划”的动作是将“规范”名词做动词使用的引申，并与后面同样名词做动词的“树”(根据树状结构拆解和递归执行的过程)相结合，其本身与英文中 Model Specification Tree 的含义一致，并且表达更生动凝练。

## 1. 概念和方法

本文所述**大语言模型**(LLM, Large Language Model)，亦或是所谓**人工智能**(AI, Artificial Intelligence)或**数学智能**(Mathematical Intelligence)需具备这样的功能：能阅读和理解自然语言的输入并在大多数场景都能给出较为准确的自然语言或其他人类可读可记录格式的输出，并具有一定常识。这里的准确性要求不是绝对的，具有同人类类似甚至略高的容错度；这里的常识也不需要很丰富，只需要达到义务教育及格水平即可；甚至并不要求具备长期记忆或自我意识这些功能。在这篇文章写成时已经有很多市面上可以使用的大模型能符合这些要求。

本文所述**规划树**(Specification Tree)源自系统工程中的管理方法，而非工业建模软件中的规格树(亦称 Specification Tree)。这种方法可表述为：将正在开发的系统的性能参数结构化，使其需求性能特征明确形成一系列或层次化的技术规范。这种方法在1960年代就已经有相似的论文提出，但在本文中的**规划树**概念并非与之完全相同，而是在此基础上提出了更具体的方法结构，即：通过树状结构逐层细分任务直至在较短的连续时间内可直接完成或确定失败的最小任务单元，随后递归执行，并在遭受失败时反馈请求介入。

模型规划树(MST)的方法仅是管理方法，其本身并不足以实现任何应用。在具体应用中除大模型工具外，还需要针对于特定需求的**规范**(Specification)，以指导大模型的输出。在实际操作中大模型预训练的内置知识仅用作自然语言理解时代基础常识，实际操作皆按照具体规范的指导执行和输出。实际操作中可能使用的规范会有很多，称为**规范库**(Specification Library)，规范库除了读写存储外还需支持检索。

本文所述的**规范**中会规定只可能有三种有效输出：

1. 成功(`done`)：直接输出成果。
2. 细分(`tree`)：需给出细分任务描述列表。
3. 失败(`fail`)：需要人工介入，若输出无法识别则默认为失败。

模型规划树的方法可表述为：

1. 从当前任务的需求描述中整理出用于检索的关键词，并匹配检索选定对应规范。
2. 根据选定规范选择输出类型并进行对应输出。
3. 程序化识别输出类型，若为成功则标记完成，若失败则请求人工介入直到不失败。
4. 若输出为细分，则程序化处对每个细分子任务递归执行此操作流程。

## 2. 规范的结构

在数据结构上，规范可细分为3个部分：

1. 标题(名称)：便于对人类可视化展示。
2. 摘要(描述)：便于大模型判定是否要采用。
3. 正文(内容)：指导大模型具体识读和输出。

这三个部分虽然可以考虑放在同一个文件内，但更推荐隔离的使用在不同场景中：例如当大模型需要判定是否使用这种规范时，仅提供摘要的信息，而具体执行过程中仅会将正文放入提示词(prompt)中，而不会包含标题和摘要的内容。

这样的数据结构类似于函数调用(Function Call)和模型上下文协议(MCP, Model Context Protocol)，但并非按照原有的 JSON 格式，而是更推荐直接以 Markdown 格式记录，这样不仅方便人类阅读，也更加适合于大模型的理解。在原有的模型上下文协议中还包含诸如唯一标识符(ID)这样的元信息，在这里不推荐作为规范数据结构的实际内容，而是建议作为文件或记录本身的名称，用例如散列值(哈希码)的方式来标识。诸如关键词(tags/keywords)之类的元信息也不适合作为文件的实际内容，而更推荐采用编制索引的方式，以避免不必要的信息冗余，这部分信息也不适合纳入规范文件的管理中，而适合采用动态的管理方式，并位于对协议开发者(Specification Developers)透明的抽象层中。

这种包含标题(title)、摘要(abstract)和正文(content)规范结构最初源于已经沿用超过百年的学术论文结构，以这样结构书写的论文经历了手写、印刷机和计算机排版软件等多种载体，存在于图书馆、数据库软件和互联网检索系统等多种索引环境，都得到了充分的利用，所承载的海量学术论文也在过去的百余年间推动了多个时代的科技发展，足以见其成熟性。在模型规划树(MST)的进一步实现中采用这样的数据结构记录规范(Specification)，符合传统习惯，也有利于兼容和复用之前的人类发展积累成果。

## 3. 任务的细分

## 4. 判定与介入

## 5. 动态响应规划

## 6. 规范自举循环

## 7. 灵感来源背景
