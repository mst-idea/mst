---
author: 廿一日船

cite:
  - "钱学森. 论系统工程[M]. 上海交通大学出版社, 2007."
  - "Murtaugh, Charles K. Specification Trees - A Tool for Management[J]. SAE International, 1967. https://doi.org/10.4271/670640"
  - "Beck, Kent, et al. Manifesto for Agile Software Development[EB/OL]. 2001. https://agilemanifesto.org/"
  - "Friedenthal, Sanford, Alan Moore, and Rick Steiner. Practical Guide to SysML: The Systems Modeling Language[M]. Amsterdam: Academic Press, 2008."
  - "OpenAI. Function Call API[EB/OL]. 2023. https://platform.openai.com/docs/guides/function-calling"
  - "Anthropic. Introducing the Model Context Protocol[EB/OL]. 2024. https://www.anthropic.com/news/model-context-protocol"
  - "OpenAI. Introducing the Model Spec[EB/OL]. 2025. https://openai.com/index/introducing-the-model-spec/"
  - "Grove, Sean. The New Code[C]. The AI Engineer World's Fair, 2025. https://www.youtube.com/watch?v=8rABwKRsec4"
---

# 模型规划树(MST)之灵感

**模型规划树** (MST, Model Specification Tree) 的灵感源于大语言**模型** (Model) + **规划树** (Specification Tree)，即：利用大语言模型理解描述并输出各类产物的功能，实现规划树这种系统工程管理方法中尽可能多的中间步骤，以尽可能减少大模型工作过程中不必要的重复人工操作，并实现更高质量的输出。

## 0. 前言

在本文写成的时代，大语言模型(LLM)技术已经发展到新的历史阶段。在过去的百余年里，尤其是设计研发方面的系统工程管理方法，即便在仅能依靠人类手动执行的阶段受到技术和人力资源限制，但也有了充分的积累。在这样的时代背景下，过去由于人力资源成本限制导致难以实施的很多更细节的管理方法便有望在大模型的辅助下实现，也有望驱动各类大模型实现更复杂的任务需求，实现更有效的反馈和更稳定的输出，让人类能专注于灵感和创意，仅介入尽可能少的必要研发生产过程。

本文并非阐述某种具体的标准规范或应用实现，本文仅是对大模型应用与系统工程结合的想法和观点，很多内容仍在思考和探讨的阶段，不要指望能像查询百科全书那样找到自己想要的任何答案。尽管本文作者也在尝试开发软件通过实践验证，但本文仅阐述作为纯粹灵感的“模型规划树(MST)”的概念。本文作者并不希望此概念被任何(包括作者本人开发的)软件、产品或平台所裹挟，因此在产生此灵感后立即将其整理成这篇文章，并开源分享给所有人。

关于其名称，为何要称为“模型规划树”而非“模型规范树”：这里的“规”就已经有“规范(Specification)”的含义，而“规划”的动作是将“规范”名词做动词使用的引申，并与后面同样名词做动词的“树”(根据树状结构拆解和递归执行的过程)相结合，其本身与英文中 Model Specification Tree 的含义一致，并且表达更生动凝练。

## 1. 概念和方法

本文所述**大语言模型**(LLM, Large Language Model)，亦或是所谓**人工智能**(AI, Artificial Intelligence)，需具备这样的功能：能阅读和理解自然语言的输入并在大多数场景都能给出较为准确的自然语言或其他人类可读可记录格式的输出，并具有一定常识。这里的准确性要求不是绝对的，具有同人类类似甚至略高的容错度；这里的常识也不需要很丰富，只需要达到义务教育及格水平即可；甚至并不要求具备长期记忆或自我意识这些功能。在这篇文章写成时已经有很多市面上可以使用的大模型能符合这些要求。

本文所述**规划树**(Specification Tree)源自系统工程中的管理方法，而非工业建模软件中的规格树(亦称 Specification Tree)。这种方法可表述为：将正在开发的系统的性能参数结构化，使其需求性能特征明确形成一系列或层次化的技术规范。这种方法在1960年代就已经有相似的论文提出，但在本文中的**规划树**概念并非与之完全相同，而是在此基础上提出了更具体的方法结构，即：通过树状结构逐层细分任务直至在较短的连续时间内可直接完成或确定失败的最小任务单元，随后递归执行，并在遭受失败时反馈请求介入。

模型规划树(MST)的方法仅是管理方法，其本身并不足以实现任何应用。在具体应用中除大模型工具外，还需要针对于特定需求的**规范**(Specification)，以指导大模型的输出。在实际操作中大模型预训练的内置知识仅用作自然语言理解时代基础常识，实际操作皆按照具体规范的指导执行和输出。实际操作中可能使用的规范会有很多，称为**规范库**(Specification Library)，规范库除了读写存储外还需支持检索。

本文所述的**规范**中会规定只可能有三种有效输出：

1. 成功(`done`)：直接输出成果。
2. 细分(`tree`)：需给出细分任务描述列表。
3. 失败(`fail`)：需要人工介入，若输出无法识别则默认为失败。

模型规划树的方法可表述为：

1. 从当前任务的需求描述中整理出用于检索的关键词，并匹配检索选定对应规范。
2. 根据选定规范选择输出类型并进行对应输出。
3. 程序化识别输出类型，若为成功则标记完成，若失败则请求人工介入直到不失败。
4. 若输出为细分，则程序化处对每个细分子任务递归执行此操作流程。

## 2. 规范的结构

在数据结构上，规范可细分为3个部分：

1. 标题(名称)：便于对人类可视化展示。
2. 摘要(描述)：便于大模型判定是否要采用。
3. 正文(内容)：指导大模型具体识读和输出。

这三个部分虽然可以考虑放在同一个文件内，但更推荐隔离的使用在不同场景中：例如当大模型需要判定是否使用这种规范时，仅提供摘要的信息，而具体执行过程中仅会将正文放入提示词(prompt)中，而不会包含标题和摘要的内容。

这样的数据结构类似于函数调用(Function Call)和模型上下文协议(MCP, Model Context Protocol)，但并非按照原有的 JSON 格式，而是更推荐直接以 Markdown 格式记录，这样不仅方便人类阅读，也更加适合于大模型的理解。在原有的模型上下文协议中还包含诸如唯一标识符(ID)这样的元信息，在这里不推荐作为规范数据结构的实际内容，而是建议作为文件或记录本身的名称，用例如散列值(哈希码)的方式来标识。诸如关键词(tags/keywords)之类的元信息也不适合作为文件的实际内容，而更推荐采用编制索引的方式，以避免不必要的信息冗余，这部分信息也不适合纳入规范文件的管理中，而适合采用动态的管理方式，并位于对协议开发者(Specification Developers)透明的抽象层中。

这种包含标题(title)、摘要(abstract)和正文(content)规范结构最初源于已经沿用超过百年的学术论文结构，以这样结构书写的论文经历了手写、印刷机和计算机排版软件等多种载体，存在于图书馆、数据库软件和互联网检索系统等多种索引环境，都得到了充分的利用，所承载的海量学术论文也在过去的百余年间推动了多个时代的科技发展，足以见其成熟性。在模型规划树(MST)的进一步实现中采用这样的数据结构记录规范(Specification)，符合传统习惯，也有利于兼容和复用之前的人类发展积累成果。

## 3. 树状图细分

如今的大模型工具(甚至所有人类本身都是如此)更擅长完成具体明确的任务，提示词的描述越准确，其完成的准确度就越高；反之，假设面对高度抽象的模糊的任务需求描述，必须很快给出输出，并且没有足够的信息提示，那么不论是大模型工具还是人类本身，都有很大概率给出错误的回答。因此需要将复杂的任务**细分**(Decomposition)为更简单的任务。

逐层递归地细分后，每个任务节点会对应零或多个子任务节点(通常不能是单个)，这样便会形成树状(Tree)的数据结构，称之为**规划树**(Specification Tree)。这种细分最终所要达到的效果是：最细致的任务将能够在单次会话中完成，仅能给出“成功”或“失败”的结果。即作为规划树的叶节点(Leaf Node)的任务是不可细分的(atomic)，也可称为**原子任务**(Atomic Task)，或**落实的任务**(Final Task)。

任务的细分有可能进入死循环(Dead Loop)，即有可能会无休止(无意义)地细分下去，永远无法落实到具体的原子任务。这种情况需要防范，例如可以程序化地根据情况设定允许细分的最深层级，并在超过这样的层级后请求外部(例如人类)介入。在规范的提示词中也需要指导大模型在什么样的情况下可以细分，若不可细分则需要请求介入。

## 4. 规范库边界

在模型规划树(MST)所设想的任务处理流程中，大模型除了基本输入输出功能外，更需要能意识到什么是自己不能做的，否则便很容易产生被“强迫”在不知情的情况下必须要给出输出结论的场景，这样的场景中非常容易产生所谓的“幻觉”。这并不仅仅是在提示词(prompt)中说明要大模型判断自己“不知道”这么简单，因为大模型对“不知道”的判断本质上仍然是一种模糊的判断，当任务变得很复杂时这种模糊的判断所造成的误差就会被逐层放大叠加，最终导致不可挽回的后果。

最简单(粗暴)且工程化的方式是将所有可能的操作都明文写入规范(Specification)之中，任何在规范库中无法检索到的操作都视为“不知道”或“无法完成”。这样的操作能够更有效地确保准确性，但也可能导致更多的人工介入。但由于规范库(Specification Library)不够齐全导致的需要人工介入的情况本就是必要的，这是在改进规范库，可以认为是在修复缺乏必要知识或信息的故障，这种场景下若不加以人工介入处理，则是人类的过失。

模型规划树(MST)的理念本身就不指望由大模型驱动的软件系统完全取代人类工作，只是期望让人类能不必再从事简单重复的不必要劳动(尤其是在这方面思考和纠结的脑力劳动)，而是将精力投入于创造性和灵感性的工作中。若全人类所有的规范库(即知识体系)都无法完成某种工作(信息壁垒和知识垄断的问题留给后文探讨)，这便意味着这种需求已经突破了人类科技水平的边界，需要通过研究扩展新的知识。

## 5. 实践测试反馈

大模型的输出的最终目的往往是直接或间接的影响现实，因此对其成功与否的判断需要由现实中的实践所检验，当然为了避免在实际使用中才暴露问题，这种实践的检验需要提前到开发阶段，即测试(Testing)。这种测试可能发生在物理层面，也可能发生在信息层面，可能是程序化的，也可能是模糊的逻辑描述形式的。例如：

1. 对于机械设计的产品，可以在实验室中测试后根据传感器参数判定是否符合需求。
2. 对于计算机程序的产品，可以通过诸如单元测试(unit test)的方式验证。
3. 对于基于想象的文学作品(如小说)，可以通过模糊的逻辑推理分析来验证。

测试可能且经常会失败，但这并不意味着测试失败了就需要立刻请求(人工)介入。例如对软件开发中的单元测试，测试失败后完全可以将测试程序的报错信息和源码再交由大模型分析从而给出修改，如此往复。但按照前文所述完全遵循规范的设计哲学，即便是测试失败后的再次尝试也需要遵循具体规范(Specification)的指导，如果没有具体的规范对于测试失败后情况的指导，则视作失败并请求介入。这种测试流程的循环可能陷入死循环，可以考虑在规范中设置超过一定次数则视作失败并请求介入。并且导致死循环的原因大概率是规范内容本身的问题，需要在规范内容的层面改进。

## 6. 动态响应规划

规划树(Specification Tree)的生成并非是一次性的：模型规划树(MST)的设计理念并不指望在最开始就能有充分落实到规划，并且参考诸如敏捷开发(Agile Development)等方法论，也很容易意识到在一开始就完成规划是不可能的。即规划树是动态的，会随执行过程中的实践反馈增添(甚至修改)原有树的结构。

稳定而固化的规划能给人更好的安全感和掌控感，但更有可能导致需求无法完成；灵活的规划更容易适应状态(甚至需求本身)的变化，但也会增加人的心智负担；因此灵活和稳定是二者不可兼得的，需要在其之间找到平衡，如若抱有“既要又要”的想法，很容易纠结内耗、反复横跳，导致二者皆不可得的悲惨结局。具体的平衡在何处还需具体问题具体分析，在本文的设想中也不可能有明确的解答。

为了保证动态响应具有更好的可读性，在这方面也需要做好充分的可视化实现，以更高的信息熵和更符合人体工程学的方式展示规划树任务节点之间的关系，这方面是模型规划树(MST)相关软件实现的关键，如若这点做不好，其用户体验上的负面影响也将极大的阻碍相关设想的实现。

## 7. 规范自举循环

由前文可见，这种模型规划树(MST)的理念很大程度上依赖于规范库(Specification Library)本身，甚至可以理解为具体的软件实践只是某种平台(platform)或套壳(shell)，**规范文本内容才是软件的核心**，而这部分规范文本的内容很可能都是直接的自然语言表述，也就是将设计哲学本身整理为文本，这也实现了类似于零代码开发的效果。

但即便是规范文本本身也并不一定要由人类亲自编写。很容易想到可以用大语言模型来根据用户提示自动生成规范，但即便是生成的规范也同样需要遵循具体的格式和内容要求，即还需要有“**规范规范的规范**(the Specification to specify Specifications)”。更进一步的，在具体实现中往往不可能仅有一份规范文档，而是会有很多可供选择的规范组成的规范库(Specification Library)，因此编写和改进规范库的工程也可以作为任务需求，交由这样的模型规划树软件系统(MST Applications)来完成，即实现所谓的“自举”。

若这样的流程能普及，那么将来的科研将变成：人类只产出关键的灵感，和处理超出现有知识体系范围的问题，提出寥寥数句的关键灵感后，相应的软件系统就会去分析、指定试验的规范、调用相应的试验设备去验证，在完成可行性验证后编写规范，更新知识体系，随后再遇到类似需求时便能复用已有的规范来实现，如此循环。

## 8. 规范库的包管理

绝大多数应用场景所需要处理的任务都会涉及特定领域的知识，即所调用的规范(Specifications)大多会集中在同一类别之内，而对其余更广泛的类别几乎不会有涉及。当然可以将所有知识体系纳入互联网的检索系统(Internet Search Engine)中，但这样很容易被海量的不相关信息淹没，浪费大量筛选成本，也容易导致被不良信息污染后准确性降低。因此需要程序化并分级地提供规范库的检索入口，而非放在同一索引空间一概而论。

目前在程序开发领域已经有成熟的**包管理系统**(Package Manager)可供参考，在规范管理中也可以采用类似的方法，即将一系列规范文件纳入某个**包**(Package)中，每个**工作空间**(Workspace)会引用诸多的包作为**依赖项**(Dependencies)，在使用中首先会检索当前工作空间依赖项中所有包内的所有规范文件(Specifications)，如果没有足以匹配任务需求的规范可供使用，再根据实际情况联网搜索，或直接请求(人工)介入。

对于这样的包管理系统当然也需要有联网的**包管理平台**(Platform)作为支撑，以便在更大的范围，乃至全世界，复用已有的规范，避免重复开发。这样的平台可能会促进规范的开源，像目前的程序开源生态(Open-source Ecosystem)这样促进全人类更自由的发展，让所有人都能更方便的复用现有科技成果；但也有可能被利益集团垄断，打造成凭借知识垄断以阶梯付费的谋利工具，在宏观上阻碍科技进步；但这并非本文的探讨范围，唯有实践才能具体地影响未来的发展方向。

## 9. 灵感来源和展望

曾经系统工程的相关理念产生了诸多管理方法，这些管理方法大多需要大量的文件编写或填写，在过去那个仅能靠人力编辑，甚至需要手写和纸质文献资料整理的年代，这种细致而复杂的规范管理方式显然会耗费大量的人力和时间，导致得不偿失，最终在绝大多数领域中都被淘汰。但基于细致的规范文件驱动的管理方式也有其优势，即能更好的确保产出的质量，而无需过度依赖于参与生产的特定个人的个性和素质。这样的管理方法在需要确保质量和安全，且对于成本不那么敏感的行业，例如部分工业生产和建筑领域，都有所保留，但在更新速度更快且成本敏感的，尤其是软件开发这样的领域中已经不再普遍，而是被新兴的诸如“敏捷开发”等理念所简化和改进。

降低成本和提升质量在很多场景都是不可兼得的，详尽的规范确实能确保质量，但也会导致成本，尤其是人力成本的上升，甚至导致在计算机技术还不发达的年代中，管理的成本会逐渐高于实际生产的成本，甚至由于人的局限性和不规范性导致僵化，在这样的系统中，很多人也不得不从事固化的规范执行性工作，从而被扼杀创新的思想。

但随着大语言模型(或者说所谓的“人工智能”)发展到如今的程度，很多文案性和按照规范执行的工作都能够用大模型来实现，而并不需要有特定的人类来执，并且大模型比人类更能适应这种不需要创造性而追求按照规范执行的工作。这就让曾经那些基于复杂而细致的规范文件的管理方式重新具有了更多的可能性，并且在如今的时代背景下，其缺陷的部分将由作为工具的大模型和程序化软件承担，而人类则存在于创新和管理的层面，而非执行的层面，在这里便更自由地发挥更多创意。

如今大语言模型就像是这样的“人类”：

1. **能读写**(理解自然语言)：这对于如今的大语言模型而言一定程度上是可以做到的。大模型能够体现出一定程度的理解能力和智能，不论这样的“智能”是否是真实的，是否具有自我意识，是否符合所谓的“伦理”，在工程上只看输入和输出的场景中是能使用的。甚至很多大模型都能输入和输出数十种自然语言，这远超过了人类的一般水平。
2. **具备基本常识**：如今大多数大模型的常识能超越受过九年义务教育的及格水平，甚至能不在指导手册的指导下编写多种编程语言的程序，这也远超过人类的一般水平。
3. **记忆及其短暂**：记忆仅存在于单次会话(session)中，超过了上下文(context)长度的极限便会清空之前的所有记忆。但如果任务足够细分，并不需要有很长的记忆。实际操作中人类也不可能清楚地记得很多细节，仍然需要有笔记之类的辅助。
4. **阅读速度极快**：目前大模型的阅读速度远超人类，其速度的限制在于算力，即便在普通的云服务API接口中，人类需要阅读数月的数十万字的书籍，大模型也能在分钟乃至秒的时间尺度内完成阅读。于是大模型在很多场景下便不需要像人类那样将知识记住，而是可以等到需要的时候再“现场学习”，快速读完指导手册(Specification)，随后快速的完成单个任务，之后便忘记一切，等下次需要的时候再重新阅读。
5. **不知疲倦**：只要电力和芯片(算力)充足。

现如今的很多管理方法，包括诸如“敏捷开发”在内的很多方法论，甚至很多相关的管理软件工具，都在尝试将任务分解为尽可能细颗粒度的基本步骤，这些步骤与前文所提的“原子需求”有类似之处，这种抽象的“人类”显然是能够胜任此类工作流程的。甚至鉴于很多软件工具都留有程序化的接口，大模型完全可以利用输入输出(I/O)的速度优势做得比人类更好。

此类模型规划树软件系统(MST Applications)在推广后有望大规模取代简单重复且枯燥的人类形式化管理工作和科研脑力工作，并进一步借助可通过程序控制的自动化流水线和机器人(具身智能)取代简单重复的人类体力工作，近乎自动化的生产出全人类生活所必要的充足产品，而人类只需要关注于知识边界的拓展和创造性的工作，实现理想中“所有人全面而自由的发展”的愿景。但实现过程中也可能存在不少风险。但在这里多说无用，世界如何发展最终还看所有人都选择和实践。
